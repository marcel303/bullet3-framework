include engine/ShaderPS.txt
include engine/ShaderUtil.txt

// shape/instance properties
uniform sampler2D u_tex;
uniform float u_hasTex;
uniform vec4 u_color;
uniform vec3 u_specularColor;

// lighting
uniform vec3 u_lightPosition_view;

shader_in vec3 v_position_view;
shader_in vec3 v_normal_view;
shader_in vec2 v_texcoord;

void main()
{
	vec3 baseColor = srgbToLinear(u_color.rgb);
	float opacity = u_color.a;

	//color.rgb *= v_normal_view;

	if (u_hasTex != 0.0)
	{
		vec4 texColor = texture(u_tex, vec2(v_texcoord.x, 1.0 - v_texcoord.y));

		baseColor *= srgbToLinear(texColor.rgb);
		opacity *= texColor.a;
	}

	// -- lighting --

	vec3 light = vec3(0.0);

	{
		vec3 lightColor = u_specularColor * vec3(4000.0);

		// -- light & surface vectors --
		vec3 delta = v_position_view - u_lightPosition_view;
		vec3 surfaceToLightVector = normalize(delta);
		vec3 normalVector = normalize(-v_normal_view);

		// -- distance attenuation --
		float distanceSquared = dot(delta, delta);
		float attenuation = 1.0 / max(0.001, distanceSquared);

		// - diffuse --
		float diffuseFactor = max(0.0, dot(surfaceToLightVector, normalVector));

		// -- specular --
		vec3 viewVector = normalize(v_position_view);

		// Blinn-Phong
		vec3 halfVector = normalize(viewVector + surfaceToLightVector);
		float specularFactor = max(0.0, dot(normalVector, halfVector));
		specularFactor = pow(specularFactor, 64.0);

		// -- debugging --
		//diffuseFactor = 0.2;
		//specularFactor = 0.0;

		// -- light accumulation --
		light += lightColor * ((diffuseFactor + specularFactor) * attenuation);

		if (true)
		{
			light *= 0.9;
			light += 0.1 * abs(srgbToLinear(surfaceToLightVector));
		}

		//light = viewVector;
		//light = normalVector;
		//light = reflectionVector;
		//light = vec3(diffuseFactor);
		//light = vec3(attenuation);
		//light = delta;
		//light *= length(delta) / 100.0;
	}

	light += vec3(0.1);

	vec3 color = linearToSrgb(baseColor * light);
	//vec3 color = linearToSrgb(light);

	shader_fragColor = vec4(color, opacity);
}
